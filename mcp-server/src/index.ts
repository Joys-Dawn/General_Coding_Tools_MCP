#!/usr/bin/env node

/**
 * General Coding Tools MCP Server
 * Exposes skills and subagents as MCP resources and tools for use in Cursor, Claude, and Smithery.
 */

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";
import { readFileSync, existsSync } from "fs";
import { createHash } from "crypto";
import { fileURLToPath } from "url";
import { dirname, join } from "path";

const __dirname = dirname(fileURLToPath(import.meta.url));

/** Escape HTML special chars so embedded user input cannot inject script if client renders as HTML. */
function escapeForEmbedding(s: string): string {
  return s
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#39;");
}

// Load bundled content (generated by scripts/bundle-content.cjs); verify integrity via SHA-256
function loadContent(): {
  skills: { id: string; name: string; hasReference: boolean }[];
  subagents: { id: string; name: string }[];
  content: {
    skills: Record<string, { content: string; reference: string | null }>;
    subagents: Record<string, { content: string }>;
    catalog?: string;
    whenToUse?: string;
    overview?: string;
  };
} {
  const contentPath = join(__dirname, "content.json");
  const hashPath = join(__dirname, "content.json.sha256");
  if (!existsSync(contentPath)) {
    throw new Error(
      "content.json not found. Run 'npm run build' from mcp-server to bundle Skills and Subagents."
    );
  }
  const raw = readFileSync(contentPath, "utf8");
  if (existsSync(hashPath)) {
    const expectedHash = readFileSync(hashPath, "utf8").trim();
    const actualHash = createHash("sha256").update(raw, "utf8").digest("hex");
    if (expectedHash !== actualHash) {
      throw new Error(
        "content.json integrity check failed (hash mismatch). Rebuild with 'npm run build' or ensure the file was not modified."
      );
    }
  }
  return JSON.parse(raw);
}

function loadVersion(): string {
  const pkgPath = join(__dirname, "..", "package.json");
  if (!existsSync(pkgPath)) return "1.0.0";
  const pkg = JSON.parse(readFileSync(pkgPath, "utf8"));
  return typeof pkg.version === "string" ? pkg.version : "1.0.0";
}

const DATA = loadContent();
const RESOURCE_PREFIX = "general-coding-tools-mcp://";

const server = new McpServer({
  name: "general-coding-tools-mcp",
  version: loadVersion(),
});

// --- Meta resources: catalog, when-to-use, overview ---
if (DATA.content.catalog) {
  const uri = `${RESOURCE_PREFIX}catalog`;
  server.registerResource(
    "catalog",
    uri,
    { title: "Catalog", description: "List of all skills and subagents with descriptions", mimeType: "text/markdown" },
    async () => ({ contents: [{ uri, mimeType: "text/markdown", text: DATA.content.catalog! }] })
  );
}
if (DATA.content.whenToUse) {
  const uri = `${RESOURCE_PREFIX}when-to-use`;
  server.registerResource(
    "when-to-use",
    uri,
    { title: "When to use", description: "Guide to choose the right skill or subagent for a request", mimeType: "text/markdown" },
    async () => ({ contents: [{ uri, mimeType: "text/markdown", text: DATA.content.whenToUse! }] })
  );
}
if (DATA.content.overview) {
  const uri = `${RESOURCE_PREFIX}overview`;
  server.registerResource(
    "overview",
    uri,
    { title: "Overview", description: "What this MCP server is and how to use it", mimeType: "text/markdown" },
    async () => ({ contents: [{ uri, mimeType: "text/markdown", text: DATA.content.overview! }] })
  );
}

// --- Resources: one per skill, skill/reference, and subagent ---
for (const s of DATA.skills) {
  const uri = `${RESOURCE_PREFIX}skill/${s.id}`;
  server.registerResource(
    `skill-${s.id}`,
    uri,
    {
      title: `Skill: ${s.name}`,
      description: `General Coding Tools skill: ${s.name}`,
      mimeType: "text/markdown",
    },
    async () => {
      const entry = DATA.content.skills[s.name];
      return {
        contents: [{ uri, mimeType: "text/markdown", text: entry.content }],
      };
    }
  );
  if (DATA.content.skills[s.name]?.reference) {
    const refUri = `${RESOURCE_PREFIX}skill/${s.id}/reference`;
    server.registerResource(
      `skill-${s.id}-reference`,
      refUri,
      {
        title: `Skill reference: ${s.name}`,
        description: `Reference material for skill ${s.name}`,
        mimeType: "text/markdown",
      },
      async () => {
        const entry = DATA.content.skills[s.name];
        return {
          contents: [{ uri: refUri, mimeType: "text/markdown", text: entry!.reference! }],
        };
      }
    );
  }
}
for (const a of DATA.subagents) {
  const uri = `${RESOURCE_PREFIX}subagent/${a.id}`;
  server.registerResource(
    `subagent-${a.id}`,
    uri,
    {
      title: `Subagent: ${a.name}`,
      description: `General Coding Tools subagent: ${a.name}`,
      mimeType: "text/markdown",
    },
    async () => {
      const entry = DATA.content.subagents[a.name];
      return {
        contents: [{ uri, mimeType: "text/markdown", text: entry.content }],
      };
    }
  );
}

// --- Tools ---
server.registerTool(
  "list_skills",
  {
    title: "List skills",
    description: "List all available General Coding Tools skills (e.g. systematic-debugging, correctness-audit).",
    inputSchema: z.object({}),
  },
  async () => {
    const list = DATA.skills.map((s) => ({ id: s.id, name: s.name, hasReference: s.hasReference }));
    return { content: [{ type: "text" as const, text: JSON.stringify(list, null, 2) }] };
  }
);

server.registerTool(
  "list_subagents",
  {
    title: "List subagents",
    description: "List all available General Coding Tools subagents (e.g. deep-research, update-docs, verifier). Subagents run in a separate agent context and return one result; use apply_subagent tool to launch.",
    inputSchema: z.object({}),
  },
  async () => {
    const list = DATA.subagents.map((a) => ({ id: a.id, name: a.name }));
    return { content: [{ type: "text" as const, text: JSON.stringify(list, null, 2) }] };
  }
);

server.registerTool(
  "get_skill",
  {
    title: "Get skill content",
    description: "Get the full content of a skill by name (id). Use list_skills to see available names.",
    inputSchema: z.object({
      name: z.string().max(200).describe("Skill id (e.g. systematic-debugging, correctness-audit)"),
      include_reference: z.boolean().optional().default(false).describe("Include REFERENCE.md if present"),
    }),
  },
  async ({ name, include_reference }) => {
    const skill = DATA.skills.find((s) => s.id === name || s.name === name);
    if (!skill) {
      return {
        content: [{ type: "text" as const, text: `Unknown skill: ${escapeForEmbedding(name)}. Use list_skills to see available skills.` }],
        isError: true,
      };
    }
    const entry = DATA.content.skills[skill.name];
    let text = entry.content;
    if (include_reference && entry.reference) {
      text += "\n\n---\n\n## Reference\n\n" + entry.reference;
    }
    return { content: [{ type: "text" as const, text }] };
  }
);

server.registerTool(
  "get_subagent",
  {
    title: "Get subagent content",
    description: "Get the full content of a subagent by name (id). Use list_subagents to see available names. Subagents are intended to be launched via apply_subagent (separate run), not followed in the current context.",
    inputSchema: z.object({
      name: z.string().max(200).describe("Subagent id (e.g. deep-research, update-docs, verifier)"),
    }),
  },
  async ({ name }) => {
    const subagent = DATA.subagents.find((a) => a.id === name || a.name === name);
    if (!subagent) {
      return {
        content: [{ type: "text" as const, text: `Unknown subagent: ${escapeForEmbedding(name)}. Use list_subagents to see available subagents.` }],
        isError: true,
      };
    }
    const entry = DATA.content.subagents[subagent.name];
    return { content: [{ type: "text" as const, text: entry.content }] };
  }
);

// --- Tool: apply_skill (agent passes user's prompt as message_to_skill so no extra form) ---
server.registerTool(
  "apply_skill",
  {
    title: "Apply a skill",
    description:
      "Load a skill and optionally scope it with the user's request. Pass the user's prompt (e.g. 'do security audit', 'audit the auth module') as message_to_skill so the skill has context without asking for input again. Returns the full skill content to follow in the current context.",
    inputSchema: z.object({
      name: z.string().max(200).describe("Skill id (e.g. systematic-debugging, security-audit)"),
      message_to_skill: z
        .string()
        .max(4000)
        .optional()
        .describe(
          "The user's request or scope — pass their message (e.g. 'security audit the auth module'). Use this when the user said what to do; avoids asking them again."
        ),
    }),
  },
  async ({ name, message_to_skill }) => {
    const skill = DATA.skills.find((s) => s.id === name || s.name === name);
    if (!skill) {
      return {
        content: [{ type: "text" as const, text: `Unknown skill: ${escapeForEmbedding(name)}. Use list_skills to see available skills.` }],
        isError: true,
      };
    }
    const entry = DATA.content.skills[skill.name];
    const extra = (message_to_skill ?? "").trim();
    const taskBlock = extra ? `\n\n**Task / scope:**\n${escapeForEmbedding(extra)}\n\n---\n\n` : "\n\n";
    const text = `I will follow the **${skill.name}** skill.${taskBlock}${entry.content}`;
    return { content: [{ type: "text" as const, text }] };
  }
);

// --- Tool: apply_subagent (agent passes user's prompt as message_to_subagent) ---
server.registerTool(
  "apply_subagent",
  {
    title: "Apply a subagent",
    description:
      "Load a subagent and optionally scope it with the user's request. Pass the user's prompt (e.g. 'run deep research on X', 'verify the last change') as message_to_subagent so no extra input is needed. Returns instructions to launch the subagent in a separate context.",
    inputSchema: z.object({
      name: z.string().max(200).describe("Subagent id (e.g. deep-research, update-docs, verifier)"),
      message_to_subagent: z
        .string()
        .max(4000)
        .optional()
        .describe(
          "The user's request or context — pass their message. Use this when the user said what they want; avoids asking again."
        ),
    }),
  },
  async ({ name, message_to_subagent }) => {
    const subagent = DATA.subagents.find((a) => a.id === name || a.name === name);
    if (!subagent) {
      return {
        content: [{ type: "text" as const, text: `Unknown subagent: ${escapeForEmbedding(name)}. Use list_subagents to see available subagents.` }],
        isError: true,
      };
    }
    const entry = DATA.content.subagents[subagent.name];
    const extra = (message_to_subagent ?? "").trim();
    const taskBlock = extra ? `\n\n**Task / context for subagent:**\n${escapeForEmbedding(extra)}` : "";
    const text = `**Launch the ${subagent.name} subagent** (separate context). Do not follow these instructions in this chat — the client must start a subagent run with the content below. The subagent runs in another context and returns one result.${taskBlock}\n\n---\n\n${entry.content}`;
    return { content: [{ type: "text" as const, text }] };
  }
);

// --- Run ---
async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
