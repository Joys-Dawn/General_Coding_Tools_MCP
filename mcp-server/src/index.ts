#!/usr/bin/env node

/**
 * General Coding Tools MCP Server
 * Exposes skills and subagents as MCP resources and tools for use in Cursor, Claude, and Smithery.
 */

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";
import { readFileSync, existsSync } from "fs";
import { fileURLToPath } from "url";
import { dirname, join } from "path";

const __dirname = dirname(fileURLToPath(import.meta.url));

// Load bundled content (generated by scripts/bundle-content.cjs)
function loadContent(): {
  skills: { id: string; name: string; hasReference: boolean }[];
  subagents: { id: string; name: string }[];
  content: {
    skills: Record<string, { content: string; reference: string | null }>;
    subagents: Record<string, { content: string }>;
  };
} {
  const contentPath = join(__dirname, "content.json");
  if (!existsSync(contentPath)) {
    throw new Error(
      "content.json not found. Run 'npm run build' from mcp-server to bundle Skills and Subagents."
    );
  }
  return JSON.parse(readFileSync(contentPath, "utf8"));
}

const DATA = loadContent();
const RESOURCE_PREFIX = "general-coding-tools-mcp://";

const server = new McpServer({
  name: "general-coding-tools-mcp",
  version: "1.0.0",
});

// --- Resources: one per skill, skill/reference, and subagent ---
for (const s of DATA.skills) {
  const uri = `${RESOURCE_PREFIX}skill/${s.id}`;
  server.registerResource(
    `skill-${s.id}`,
    uri,
    {
      title: `Skill: ${s.name}`,
      description: `General Coding Tools skill: ${s.name}`,
      mimeType: "text/markdown",
    },
    async () => {
      const entry = DATA.content.skills[s.name];
      return {
        contents: [{ uri, mimeType: "text/markdown", text: entry.content }],
      };
    }
  );
  if (DATA.content.skills[s.name]?.reference) {
    const refUri = `${RESOURCE_PREFIX}skill/${s.id}/reference`;
    server.registerResource(
      `skill-${s.id}-reference`,
      refUri,
      {
        title: `Skill reference: ${s.name}`,
        description: `Reference material for skill ${s.name}`,
        mimeType: "text/markdown",
      },
      async () => {
        const entry = DATA.content.skills[s.name];
        return {
          contents: [{ uri: refUri, mimeType: "text/markdown", text: entry!.reference! }],
        };
      }
    );
  }
}
for (const a of DATA.subagents) {
  const uri = `${RESOURCE_PREFIX}subagent/${a.id}`;
  server.registerResource(
    `subagent-${a.id}`,
    uri,
    {
      title: `Subagent: ${a.name}`,
      description: `General Coding Tools subagent: ${a.name}`,
      mimeType: "text/markdown",
    },
    async () => {
      const entry = DATA.content.subagents[a.name];
      return {
        contents: [{ uri, mimeType: "text/markdown", text: entry.content }],
      };
    }
  );
}

// --- Tools ---
server.registerTool(
  "list_skills",
  {
    title: "List skills",
    description: "List all available General Coding Tools skills (e.g. systematic-debugging, correctness-audit).",
    inputSchema: z.object({}),
  },
  async () => {
    const list = DATA.skills.map((s) => ({ id: s.id, name: s.name, hasReference: s.hasReference }));
    return { content: [{ type: "text" as const, text: JSON.stringify(list, null, 2) }] };
  }
);

server.registerTool(
  "list_subagents",
  {
    title: "List subagents",
    description: "List all available General Coding Tools subagents (e.g. deep-research, update-docs, verifier).",
    inputSchema: z.object({}),
  },
  async () => {
    const list = DATA.subagents.map((a) => ({ id: a.id, name: a.name }));
    return { content: [{ type: "text" as const, text: JSON.stringify(list, null, 2) }] };
  }
);

server.registerTool(
  "get_skill",
  {
    title: "Get skill content",
    description: "Get the full content of a skill by name (id). Use list_skills to see available names.",
    inputSchema: z.object({
      name: z.string().describe("Skill id (e.g. systematic-debugging, correctness-audit)"),
      include_reference: z.boolean().optional().default(false).describe("Include REFERENCE.md if present"),
    }),
  },
  async ({ name, include_reference }) => {
    const skill = DATA.skills.find((s) => s.id === name || s.name === name);
    if (!skill) {
      return {
        content: [{ type: "text" as const, text: `Unknown skill: ${name}. Use list_skills to see available skills.` }],
        isError: true,
      };
    }
    const entry = DATA.content.skills[skill.name];
    let text = entry.content;
    if (include_reference && entry.reference) {
      text += "\n\n---\n\n## Reference\n\n" + entry.reference;
    }
    return { content: [{ type: "text" as const, text }] };
  }
);

server.registerTool(
  "get_subagent",
  {
    title: "Get subagent content",
    description: "Get the full content of a subagent by name (id). Use list_subagents to see available names.",
    inputSchema: z.object({
      name: z.string().describe("Subagent id (e.g. deep-research, update-docs, verifier)"),
    }),
  },
  async ({ name }) => {
    const subagent = DATA.subagents.find((a) => a.id === name || a.name === name);
    if (!subagent) {
      return {
        content: [{ type: "text" as const, text: `Unknown subagent: ${name}. Use list_subagents to see available subagents.` }],
        isError: true,
      };
    }
    const entry = DATA.content.subagents[subagent.name];
    return { content: [{ type: "text" as const, text: entry.content }] };
  }
);

// --- Prompts: apply skill / subagent with user message ---
for (const s of DATA.skills) {
  const promptName = `apply_skill_${s.id.replace(/-/g, "_")}`;
  server.registerPrompt(
    promptName,
    {
      title: `Apply skill: ${s.name}`,
      description: `Apply the "${s.name}" skill. Use when the user wants to follow this skill's process.`,
      argsSchema: {
        user_message: z.string().describe("What the user asked or the current task"),
      },
    },
    async ({ user_message }) => {
      const entry = DATA.content.skills[s.name];
      const text = `I will follow the **${s.name}** skill.\n\n---\n\n${entry.content}\n\n---\n\nUser request: ${user_message ?? "(no message provided)"}`;
      return {
        messages: [
          { role: "user" as const, content: { type: "text" as const, text: String(user_message ?? "") } },
          { role: "assistant" as const, content: { type: "text" as const, text } },
        ],
      };
    }
  );
}
for (const a of DATA.subagents) {
  const promptName = `apply_subagent_${a.id.replace(/-/g, "_")}`;
  server.registerPrompt(
    promptName,
    {
      title: `Apply subagent: ${a.name}`,
      description: `Apply the "${a.name}" subagent. Use when the user wants this agent's behavior.`,
      argsSchema: {
        user_message: z.string().describe("What the user asked or the current task"),
      },
    },
    async ({ user_message }) => {
      const entry = DATA.content.subagents[a.name];
      const text = `I will follow the **${a.name}** subagent.\n\n---\n\n${entry.content}\n\n---\n\nUser request: ${user_message ?? "(no message provided)"}`;
      return {
        messages: [
          { role: "user" as const, content: { type: "text" as const, text: String(user_message ?? "") } },
          { role: "assistant" as const, content: { type: "text" as const, text } },
        ],
      };
    }
  );
}

// --- Run ---
async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
